<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title> TypeScript - Hugo TypScript Scenarios </title>
    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="320">
    <meta name="referrer" content="no-referrer">
    <meta name="description" content="" />
    <meta property="og:site_name" content="Hugo TypScript Scenarios" />
    <meta property="og:locale" content="en_US" />
    <meta property="og:type" content="article" />
    <meta property="og:url" content="https://example.com/posts/typescript/" />
    <meta property="og:title" content="TypeScript" />
    <meta property="og:image" content="https://example.com" />
    <meta property="og:description" content="" />

    <meta name="twitter:card" content="summary_large_image" />
    
    <meta name="twitter:title" content="TypeScript" />
    <meta name="twitter:description" content="" />
    <meta name="twitter:image" content="https://example.com" />

    <link rel="canonical" href="https://example.com/posts/typescript/">

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.5.2/css/bootstrap.min.css" integrity="sha512-MoRNloxbStBcD8z3M/2BmnT+rg4IsMxPkXaGh2zD6LGNNFE80W3onsAhRcMAMrSoyWL9xD7Ert0men7vR8LUZg==" crossorigin="anonymous" />

    <link rel="stylesheet" href="https://example.comcss/custom.css" />

    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.0/styles/github-gist.min.css" integrity="sha512-od7JLoOTxM8w/HSKGzP9Kexc20K9p/M2zxSWsd7H1e4Ctf+8SQFtCWEZnW5u6ul5ehSECa5QmOk9ju2nQMmlVA==" crossorigin="anonymous" />
    

    

    <link rel="shortcut icon"
        href="https://example.com/images/favicon.png">

    
    <link href="https://example.com/index.xml" rel="alternate" type="application/rss+xml" title="Hugo TypScript Scenarios" />
    
</head>

<body>
    
    <div class="mt-xl header">
    <div class="container">
        <div class="row justify-content-center">
            <div class="col-auto">
                <a href="https://example.com">
                    <h1 class="name">Hugo Tanka Theme</h1>
                </a>
            </div>
        </div>

        <div class="row justify-content-center">
            <ul class="nav nav-primary">
                
                <li class="nav-item">
                    <a class="nav-link" href="https://example.com/">
                        
                        Home
                    </a>
                </li>
                
            </ul>
        </div>
    </div>
</div>

    <div class="content">
        <div class="container">
            <div class="row justify-content-center">
                <div class="col-sm-12 col-lg-8">
                    <h1 class="mx-0 mx-md-4">TypeScript</h1>
                    <div class="markdown">
                        
    <h1 id="100-scenarios">100 SCENARIOS</h1>
<p><strong>1) Create a simple message on TypeScript</strong></p>
<p>var message:string = &ldquo;Hello World&rdquo;
console.log(message)</p>
<p>On compiling, it will generate following JavaScript code.</p>
<p>//Generated by typescript 1.8.10
var message = &ldquo;Hello World&rdquo;;
console.log(message);</p>
<p><strong>2) Run/Compile</strong></p>
<p>tsc Test.ts
node Test.js</p>
<p><strong>3) Multiple files can be run at once</strong></p>
<p>Example : tsc file1.ts, file2.ts, file3.ts</p>
<p><strong>4) TypeScript is Case-sensitive</strong></p>
<p>console.log(&ldquo;hello world&rdquo;)
console.log(&ldquo;We are learning TypeScript&rdquo;</p>
<p><strong>5) TypeScript and Object Orientation</strong></p>
<p>Object − An object is a real time representation of any entity. According to Grady Brooch, every object must have three features −</p>
<p>State − described by the attributes of an object</p>
<p>Behavior − describes how the object will act</p>
<p>Identity − a unique value that distinguishes an object from a set of similar such objects.</p>
<p>Class − A class in terms of OOP is a blueprint for creating objects. A class encapsulates data for the object.</p>
<p>Method − Methods facilitate communication between objects.</p>
<p>Example:</p>
<p>class Greeting {
greet():void {
console.log(&ldquo;Hello World!!!&quot;)
}
}
var obj = new Greeting();
obj.greet();</p>
<p>The above example defines a class Greeting. The class has a method greet (). The method prints the string “Hello World” on the terminal. The new keyword creates an object of the class (obj). The object invokes the method greet ().</p>
<p>On compiling, it will generate following JavaScript code.</p>
<p><strong>6) Variable Declaration in TypeScript</strong></p>
<p>The type syntax for declaring a variable in TypeScript is to include a colon (:) after the variable name, followed by its type.
(i) var name:string = ”mary” =&gt; The variable stores a value of type string
(ii) var name:string; =&gt; The variable is a string variable. The variable’s value is set to undefined by default
(iii) var name = ”mary” =&gt; The variable’s type is inferred from the data type of the value. Here, the variable is of the type string
(iv) var name; =&gt; The variable’s data type is any. Its value is set to undefined by default.</p>
<p>Example :
var name:string = &ldquo;John&rdquo;;
var score1:number = 50;
var score2:number = 42.50
var sum = score1 + score2
console.log(&ldquo;name&quot;+name)
console.log(&ldquo;first score: &ldquo;+score1)
console.log(&ldquo;second score: &ldquo;+score2)</p>
<p><strong>7) Type Assertion in TypeScript</strong></p>
<p>TypeScript allows changing a variable from one type to another. TypeScript refers to this process as Type Assertion. The syntax is to put the target type between &lt; &gt; symbols and place it in front of the variable or expression. The following example explains this concept −</p>
<p>Example
var str = &lsquo;1&rsquo;
var str2:number = <number><any>str //str is now of type number
console.log(typeof(str2))
console.log(&ldquo;sum of the scores: &ldquo;+sum)</any></number></p>
<p><strong>8) TypeScript Variable Scope</strong></p>
<p>The scope of a variable specifies where the variable is defined. The availability of a variable within a program is determined by its scope. TypeScript variables can be of the following scopes −</p>
<p>Global Scope − Global variables are declared outside the programming constructs. These variables can be accessed from anywhere within your code.</p>
<p>Class Scope − These variables are also called fields. Fields or class variables are declared within the class but outside the methods. These variables can be accessed using the object of the class. Fields can also be static. Static fields can be accessed using the class name.</p>
<p>Local Scope − Local variables, as the name suggests, are declared within the constructs like methods, loops etc. Local variables are accessible only within the construct where they are declared.</p>
<p>Example: Variable Scope
var global_num = 12 //global variable
class Numbers {
num_val = 13; //class variable
static sval = 10; //static field</p>
<p>storeNum():void {
var local_num = 14; //local variable
}
}
console.log(&ldquo;Global num: &ldquo;+global_num)
console.log(Numbers.sval) //static variable
var obj = new Numbers();
console.log(&ldquo;Global num: &ldquo;+obj.num_val)</p>
<ol start="9">
<li><strong>while versus do..while</strong></li>
</ol>
<p>var n:number = 5</p>
<p>while(n &gt; 5) {</p>
<p>console.log(&ldquo;Entered while&rdquo;)</p>
<p>}</p>
<p>do {</p>
<p>console.log(&ldquo;Entered do…while&rdquo;)</p>
<p>}</p>
<p>while(n&gt;5)</p>
<p><strong>10) Continue statements on TypeScript</strong></p>
<p>var num:number = 0</p>
<p>var count:number = 0;</p>
<p>for(num=0;num&lt;=20;num++) {</p>
<p>if (num % 2==0) {</p>
<p>continue</p>
<p>}</p>
<p>count++</p>
<p>}</p>
<p>console.log (&rdquo; The count of odd values between 0 and 20 is: &ldquo;+count) //outputs 10</p>
<p>Here the example displays the odd values from 0 to 20 . The loop exits the current iteration if the no. is even , that is achieved using continue statement.</p>
<p><strong>11) The break Statement in Typescript</strong></p>
<p>The <strong>break</strong> statement is used to take the control out of a construct. Using <strong>break</strong> in a loop causes the program to exit the loop. Its syntax is as follows :</p>
<p>Program :</p>
<p>var i:number = 1</p>
<p>while(i&lt;=10) {</p>
<p>if (i % 5 == 0) {</p>
<p>console.log (&ldquo;The first multiple of 5 between 1 and 10 is : &ldquo;+i)</p>
<p>break //exit the loop if the first multiple is found</p>
<p>}</p>
<p>i++</p>
<p>} //outputs 5 and exits the loop</p>
<ol start="12">
<li>Infinite loop using for loop</li>
</ol>
<p>Infinite loop runs endlessly, for and while loop can be used to make it run infinitely.</p>
<p>Syntax :</p>
<p>for(;;) {</p>
<p>//statements</p>
<p>Example :</p>
<p>for(;;) {</p>
<p>console.log(&ldquo;This is an endless loop&rdquo;)</p>
<p>}</p>
<p><strong>13) Infinite loop using while loop</strong></p>
<p>Syntax:</p>
<p>while(true) {</p>
<p>//statements</p>
<p>}</p>
<p>Example: Infinite loop using while loop</p>
<p>while(true) {</p>
<p>console.log(&ldquo;This is an endless loop&rdquo;)</p>
<p>}</p>
<p><strong>14) Inferred Typing in TypeScript</strong></p>
<p>Given the fact that, Typescript is strongly typed, this feature is optional. TypeScript also encourages dynamic typing of variables. This means that, TypeScript encourages declaring a variable without a type. In such cases, the compiler will determine the type of the variable on the basis of the value assigned to it. TypeScript will find the first usage of the variable within the code, determine the type to which it has been initially set and then assume the same type for this variable in the rest of your code block.</p>
<p>Example: Inferred Typing</p>
<p>var num = 2; // data type inferred as number</p>
<p>console.log(&ldquo;value of num &ldquo;+num);</p>
<p>num = &ldquo;12&rdquo;;</p>
<p>console.log(num);</p>
<p>The code declares a variable and sets its value to 2. Note that the variable declaration doesn&rsquo;t specify the data type. Hence, the program uses inferred typing to determine the data type of the variable, i.e., it assigns the type of the first value that the variable is set to. In this case, num is set to the type number.</p>
<p>When the code tries to set the variable&rsquo;s value to string. The compiler throws an error as the variable&rsquo;s type is already set to number.</p>
<p>It will produce the following output − error TS2011: Cannot convert &lsquo;string&rsquo; to &lsquo;number&rsquo;.</p>
<p><strong>15) Arithmetic Operators</strong></p>
<p>Example :</p>
<p>var num1:number = 10</p>
<p>var num2:number = 2</p>
<p>var res:number = 0</p>
<p>res = num1 + num2</p>
<p>console.log(&ldquo;Sum: &ldquo;+res);</p>
<p>res = num1 - num2;</p>
<p>console.log(&ldquo;Difference: &ldquo;+res)</p>
<p>res = num1*num2</p>
<p>console.log(&ldquo;Product: &ldquo;+res)</p>
<p>res = num1/num2</p>
<p>console.log(&ldquo;Quotient: &ldquo;+res)</p>
<p>res = num1%num2</p>
<p>console.log(&ldquo;Remainder: &ldquo;+res)</p>
<p>num1++</p>
<p>console.log(&ldquo;Value of num1 after increment &ldquo;+num1)</p>
<p>num2&ndash;</p>
<p>console.log(&ldquo;Value of num2 after decrement &ldquo;+num2)</p>
<p><strong>16) Relational Operators</strong></p>
<p>Example :</p>
<p>var num1:number = 5;</p>
<p>var num2:number = 9;</p>
<p>console.log(&ldquo;Value of num1: &ldquo;+num1);</p>
<p>console.log(&ldquo;Value of num2 :&ldquo;+num2);</p>
<p>var res = num1&gt;num2</p>
<p>console.log(&ldquo;num1 greater than num2: &ldquo;+res)</p>
<p>res = num1&lt;num2</p>
<p>console.log(&ldquo;num1 lesser than num2: &ldquo;+res)</p>
<p>res = num1&gt;=num2</p>
<p>console.log(&ldquo;num1 greater than or equal to num2: &ldquo;+res)</p>
<p>res = num1&lt;=num2</p>
<p>console.log(&ldquo;num1 lesser than or equal to num2: &ldquo;+res)</p>
<p>res = num1==num2</p>
<p>console.log(&ldquo;num1 is equal to num2: &ldquo;+res)</p>
<p>res = num1!=num2</p>
<p>console.log(&ldquo;num1 is not equal to num2: &ldquo;+res)</p>
<p><strong>17) Bitwise Operators</strong></p>
<p>Example :</p>
<p>var a:number = 2; // Bit presentation 10</p>
<p>var b:number = 3; // Bit presentation 11</p>
<p>var result;</p>
<p>result = (a &amp; b);</p>
<p>console.log(&quot;(a &amp; b) =&gt; &ldquo;,result)</p>
<p>result = (a | b);</p>
<p>console.log(&quot;(a | b) =&gt; &ldquo;,result)</p>
<p>result = (a ^ b);</p>
<p>console.log(&quot;(a ^ b) =&gt; &ldquo;,result);</p>
<p>result = (~b);</p>
<p>console.log(&quot;(~b) =&gt; &ldquo;,result);</p>
<p>result = (a &laquo; b);</p>
<p>console.log(&quot;(a &lt;&lt; b) =&gt; &ldquo;,result);</p>
<p>result = (a &raquo; b);</p>
<p>console.log(&quot;(a &raquo; b) =&gt; &ldquo;,result);</p>
<p>This will simultaneously generate a JavaScript code .</p>
<p>Output :</p>
<p>(a &amp; b) =&gt; 2</p>
<p>(a | b) =&gt; 3</p>
<p>(a ^ b) =&gt; 1</p>
<p>(~b) =&gt; -4</p>
<p>(a &lt;&lt; b) =&gt; 16</p>
<p>(a &raquo; b) =&gt; 0</p>
<p><strong>18) Logical Operators</strong></p>
<p>Logical Operators are used to combine two or more conditions. Logical operators too return a Boolean value. Assume the value of variable A is 10 and B is 20.</p>
<p>Example :</p>
<p>var avg:number = 20;</p>
<p>var percentage:number = 90;</p>
<p>console.log(&ldquo;Value of avg: &ldquo;+avg+&rdquo; ,value of percentage: &ldquo;+percentage);</p>
<p>var res:boolean = ((avg&gt;50)&amp;&amp;(percentage&gt;80));</p>
<p>console.log(&quot;(avg&gt;50)&amp;&amp;(percentage&gt;80): &ldquo;,res);</p>
<p>var res:boolean = ((avg&gt;50)||(percentage&gt;80));</p>
<p>console.log(&quot;(avg&gt;50)||(percentage&gt;80): &ldquo;,res);</p>
<p>var res:boolean=!((avg&gt;50)&amp;&amp;(percentage&gt;80));</p>
<p>console.log(&quot;!((avg&gt;50)&amp;&amp;(percentage&gt;80)): &ldquo;,res);</p>
<p>Output :</p>
<p>Value of avg: 20 ,value of percentage: 90</p>
<p>(avg &gt; 50)&amp;&amp;(percentage &gt; 80): false</p>
<p>(avg &gt; 50)||(percentage &gt; 80): true</p>
<p>!((avg &gt; 50)&amp;&amp;(percentage &gt; 80)): true</p>
<p><strong>19) Assignment Operators</strong></p>
<p>Note − Same logic applies to Bitwise operators, so they will become &lt;&lt;=, &gt;&gt;=, &raquo;=, &amp;=, |= and ^=.</p>
<p>Example :</p>
<p>var a: number = 12</p>
<p>var b:number = 10</p>
<p>a = b</p>
<p>console.log(&ldquo;a = b: &ldquo;+a)</p>
<p>a += b</p>
<p>console.log(&ldquo;a+=b: &ldquo;+a)</p>
<p>a -= b</p>
<p>console.log(&ldquo;a-=b: &ldquo;+a)</p>
<p>a *= b</p>
<p>console.log(&ldquo;a*=b: &ldquo;+a)</p>
<p>a /= b</p>
<p>console.log(&ldquo;a/=b: &ldquo;+a)</p>
<p>a %= b</p>
<p>console.log(&ldquo;a%=b: &ldquo;+a)</p>
<p>It will produce the following output −</p>
<p>a = b: 10</p>
<p>a += b: 20</p>
<p>a -= b: 10</p>
<p>a *= b: 100</p>
<p>a /= b: 10</p>
<p>a %= b: 0</p>
<p><strong>20) Miscallaneous Operators</strong></p>
<p>The negation operator (-) changes the sign of a value.</p>
<p>Example :</p>
<p>var x:number = 4</p>
<p>var y = -x;</p>
<p>console.log(&ldquo;value of x: &ldquo;,x); //outputs 4</p>
<p>console.log(&ldquo;value of y: &ldquo;,y); //outputs -4</p>
<p><strong>21) Type Operators</strong></p>
<p>(typeof operator)</p>
<p>It is a unary operator. This operator returns the data type of the operand. Take a look at the following Example −</p>
<p>var num = 12</p>
<p>console.log(typeof num); //output: number</p>
<p><strong>22) instanceof Operators</strong></p>
<p>This operator can be used to test if an object is of a specified type or not. The use of instanceof operator is discussed in the chapter classes.</p>
<p><strong>23) String Operators: Concatenation operator (+)</strong></p>
<p>The + operator when applied to strings appends the second string to the first. The following example helps us to understand this concept.</p>
<p>var msg:string = &ldquo;hello&quot;+&quot;world&rdquo;</p>
<p>console.log(msg)</p>
<p>On compiling, it will generate following JavaScript code.</p>
<p>//Generated by typescript 1.8.10</p>
<p>var msg = &ldquo;hello&rdquo; + &ldquo;world&rdquo;;</p>
<p>console.log(msg);</p>
<p>It will produce the following output −</p>
<p>helloworld</p>
<p>The concatenation operation doesn&rsquo;t add a space between strings. Multiple strings can be concatenated in a single statement.</p>
<p><strong>24) Conditional Operator (?)</strong></p>
<p>This operator is used to represent a conditional expression. The conditional operator is also sometimes referred to as the ternary operator. The syntax is as given below −</p>
<p>Test ? expr1 : expr2</p>
<p>Test − refers to the conditional expression</p>
<p>expr1 − value returned if the condition is true</p>
<p>expr2 − value returned if the condition is false</p>
<p>Example :</p>
<p>var num:number = -2</p>
<p>var result = num &gt; 0 ?&ldquo;positive&rdquo;:&ldquo;non-positive&rdquo;</p>
<p>console.log(result)</p>
<p>Line 2 checks whether the value in the variable num is greater than zero. If num is set to a value greater than zero, it returns the string &ldquo;positive&rdquo; else the string &ldquo;non-positive&rdquo; is returned.</p>
<p><strong>25) Short-circuit Operators (&amp;&amp; and ||)</strong></p>
<p>The &amp;&amp; and || operators are used to combine expressions. The &amp;&amp; operator returns true only when both the conditions return true. Let us consider an expression −</p>
<p>var a = 10</p>
<p>var result = ( a&lt;10 &amp;&amp; a&gt;5)</p>
<p>In the above example, a &lt; 10 and a &gt; 5 are two expressions combined by an &amp;&amp; operator. Here, the first expression returns false. However, the &amp;&amp; operator requires both the expressions return true. So, the operator skips the second expression.</p>
<p>The || operator returns true, if one of the expressions returns true. For example −</p>
<p>var a = 10</p>
<p>var result = ( a&gt;5 || a&lt;10)</p>
<p>In the above snippet, two expressions a &gt; 5 and a &lt; 10 are combined by a || operator. Here, the first expression returns true. Since, the first expression returns true, the || operator skips the subsequent expression and returns true.</p>
<p>Due to this behavior of the &amp;&amp; and || operator, they are called as short-circuit operators.</p>
<p><strong>26) Defining a function in TypeScript</strong></p>
<p>A function definition specifies what and how a specific task would be done. Before using a function, it must be defined. Functions are defined using the function keyword. The syntax for defining a standard function is given below −</p>
<p>Syntax :</p>
<p>function function_name() {</p>
<p>// function body</p>
<p>}</p>
<p>Example: simple function definition</p>
<p>function () {</p>
<p>//function definition</p>
<p>console.log(&ldquo;function called&rdquo;)</p>
<p>}</p>
<p><strong>27) Calling a Function in TypeScript</strong></p>
<p>A function must be called so as to execute it. This process is termed as function invocation.</p>
<p>Syntax :</p>
<p>Function_name()</p>
<p>Example :</p>
<p>function test() { // function definition</p>
<p>console.log(&ldquo;function called&rdquo;)</p>
<p>}</p>
<p>test() // function invocation</p>
<p>On compiling, it will generate the same JavaScript code.</p>
<p>function test() {</p>
<p>console.log(&ldquo;function called&rdquo;);</p>
<p>}</p>
<p>test(); // function invocation</p>
<p>Output : function called</p>
<p><strong>28) Returning a function in TypeScript</strong></p>
<p>Functions may also return value along with control, back to the caller. Such functions are called as returning functions.</p>
<p>Syntax :</p>
<p>function function_name():return_type {</p>
<p>//statements</p>
<p>return value;</p>
<p>}</p>
<p>The return_type can be any valid data type.A returning function must end with a return statement.</p>
<p>A function can return at the most one value. In other words, there can be only one return statement per function.</p>
<p>The data type of the value returned must match the return type of the function.</p>
<p>Example :</p>
<p>//function defined</p>
<p>function greet():string { //the function returns a string</p>
<p>return &ldquo;Hello World&rdquo;</p>
<p>}</p>
<p>function caller() {</p>
<p>var msg = greet() //function greet() invoked</p>
<p>console.log(msg)</p>
<p>}</p>
<p>//invoke function</p>
<p>caller()</p>
<p>The example declares a function greet(). The function&rsquo;s return type is string.</p>
<p>Line function returns a string value to the caller. This is achieved by the return statement.</p>
<p>The function greet() returns a string, which is stored in the variable msg. This is later displayed as output.</p>
<p>The output of the above code is as follows : Hello World</p>
<p><strong>29) Parameterize a function in TypeScript</strong></p>
<p>Parameters are a mechanism to pass values to functions. Parameters form a part of the function&rsquo;s signature. The parameter values are passed to the function during its invocation. Unless explicitly specified, the number of values passed to a function must match the number of parameters defined.</p>
<p>While calling a function, there are two ways that arguments can be passed to a function −</p>
<p>1.Call by value</p>
<p>This method copies the actual value of an argument into the formal parameter of the function. In this case, changes made to the parameter inside the function have no effect on the argument.</p>
<p>2.Call by pointer</p>
<p>This method copies the address of an argument into the formal parameter. Inside the function, the address is used to access the actual argument used in the call. This means that changes made to the parameter</p>
<p>Positional Parameters</p>
<p>function func_name( param1 [:datatype], ( param2 [:datatype]) {</p>
<p>}</p>
<p>Example: Positional parameters</p>
<p>function test_param(n1:number,s1:string) {</p>
<p>console.log(n1)</p>
<p>console.log(s1)</p>
<p>}</p>
<p>test_param(123,&ldquo;this is a string&rdquo;)</p>
<p>The snippet declares a function test_param with three parameters namely, n1, s1 and p1.</p>
<p>It is not mandatory to specify the data type of the parameter. In the absence of a data type, the parameter is considered to be of the type any. In the above example, the third parameter will be of the type any.</p>
<p>The data type of the value passed must match the type of the parameter during its declaration. In case the data types don&rsquo;t match, the compiler throws an error.</p>
<p>On compiling, it will generate following JavaScript code.</p>
<p>//Generated by typescript</p>
<p>function test_param(n1, s1) {</p>
<p>console.log(n1);</p>
<p>console.log(s1);</p>
<p>}</p>
<p>test_param(123, &ldquo;this is a string&rdquo;);</p>
<p>Output :</p>
<p>123</p>
<p>this is a string</p>
<h3 id="30-optional-parameters"><strong>30) Optional Parameters</strong></h3>
<p>Optional parameters can be used when arguments need not be compulsorily passed for a function&rsquo;s execution. A parameter can be marked optional by appending a question mark to its name. The optional parameter should be set as the last argument in a function. Syntax :</p>
<p>function function_name (param1[:type], param2[:type], param3[:type])</p>
<p>Example:</p>
<p>function disp_details(id:number,name:string,mail_id?:string) {</p>
<p>console.log(&ldquo;ID:&quot;, id);</p>
<p>console.log(&ldquo;Name&rdquo;,name);</p>
<p>if(mail_id!=undefined)</p>
<p>console.log(&ldquo;Email Id&rdquo;,mail_id);</p>
<p>}</p>
<p>disp_details(123,&ldquo;John&rdquo;);</p>
<p>disp_details(111,&ldquo;mary&rdquo;,&ldquo;<a href="mailto:mary@xyz.com">mary@xyz.com</a>&rdquo;);</p>
<p>Output:</p>
<p>ID:123</p>
<p>Name John</p>
<p>ID: 111</p>
<p>Name mary</p>
<p>Email Id <a href="mailto:mary@xyz.com">mary@xyz.com</a></p>
<h3 id="31-rest-parameters"><strong>31) Rest Parameters</strong></h3>
<p>Rest parameters are similar to variable arguments in Java. Rest parameters don&rsquo;t restrict the number of values that you can pass to a function. However, the values passed must all be of the same type. In other words, rest parameters act as placeholders for multiple arguments of the same type.</p>
<p>To declare a rest parameter, the parameter name is prefixed with three periods. Any nonrest parameter should come before the rest parameter.</p>
<p>Example:</p>
<p>function addNumbers(&hellip;nums:number[]) {</p>
<p>var i;</p>
<p>var sum:number = 0;</p>
<p>for(i = 0;i&lt;nums.length;i++) {</p>
<p>sum = sum + nums[i];</p>
<p>}</p>
<p>console.log(&ldquo;sum of the numbers&rdquo;,sum)</p>
<p>}</p>
<p>addNumbers(1,2,3)</p>
<p>addNumbers(10,10,10,10,10)</p>
<p>The function addNumbers() declaration, accepts a rest parameter nums. The rest parameter&rsquo;s data type must be set to an array. Moreover, a function can have at the most one rest parameter.</p>
<p>The function is invoked twice, by passing three and six values, respectively.</p>
<p>The for loop iterates through the argument list, passed to the function and calculates their sum.</p>
<p>Output :−</p>
<p>sum of numbers 6</p>
<p>sum of numbers 50</p>
<h3 id="32-default-parameters"><strong>32) Default Parameters</strong></h3>
<p>Function parameters can also be assigned values by default. However, such parameters can also be explicitly passed values.</p>
<p>Syntax :</p>
<p>function function_name(param1[:type],param2[:type] = default_value) {</p>
<p>}</p>
<p>Note − A parameter cannot be declared optional and default at the same time.</p>
<p>Example:</p>
<p>function calculate_discount(price:number,rate:number = 0.50) {</p>
<p>var discount = price * rate;</p>
<p>console.log(&ldquo;Discount Amount: &ldquo;,discount);</p>
<p>}</p>
<p>calculate_discount(1000)</p>
<p>calculate_discount(1000,0.30)</p>
<p>Output :</p>
<p>Discount amount : 500</p>
<p>Discount amount : 300</p>
<p>The example declares the function, calculate_discount. The function has two parameters - price and rate.</p>
<p>The value of the parameter rate is set to 0.50 by default.</p>
<p>The program invokes the function, passing to it only the value of the parameter price. Here, the value of rate is 0.50 (default)</p>
<p>The same function is invoked, but with two arguments. The default value of rate is overwritten and is set to the value explicitly passed.</p>
<h3 id="33-anonymous-function"><strong>33) Anonymous Function</strong></h3>
<p>Functions that are not bound to an identifier (function name) are called as anonymous functions. These functions are dynamically declared at runtime. Anonymous functions can accept inputs and return outputs, just as standard functions do. An anonymous function is usually not accessible after its initial creation.</p>
<p>Variables can be assigned an anonymous function. Such an expression is called a function expression.</p>
<p>Syntax :</p>
<p>var res = function( [arguments] ) { &hellip; }</p>
<p>Example ─ A Simple Anonymous function</p>
<p>var msg = function() {</p>
<p>return &ldquo;hello world&rdquo;;</p>
<p>}</p>
<p>console.log(msg())</p>
<p>On compiling, it will generate the same code in JavaScript.</p>
<p>Output :</p>
<p>hello world</p>
<p>Example : Anonymous function with parameters</p>
<p>var res = function(a:number,b:number) {</p>
<p>return a*b;</p>
<p>};</p>
<p>console.log(res(12,2))</p>
<p>The anonymous function returns the product of the values passed to it.</p>
<p>Output :</p>
<p>24</p>
<h3 id="34-function-expression-and-function-declaration">34) Function Expression and Function Declaration </h3>
<p>Function expression and function declaration are not synonymous. Unlike a function expression, a function declaration is bound by the function name.</p>
<p>The fundamental difference between the two is that, function declarations are parsed before their execution. On the other hand, function expressions are parsed only when the script engine encounters it during execution.</p>
<p>When the JavaScript parser sees a function in the main code flow, it assumes Function Declaration. When a function comes as a part of a statement, it is a Function Expression.</p>
<h3 id="35-the-function-constructor"><strong>35) The Function Constructor</strong></h3>
<p>TypeScript also supports defining a function with the built-in JavaScript constructor called Function ().</p>
<p>Syntax :</p>
<p>var res = new Function( [arguments] ) { &hellip; }.</p>
<p>Example</p>
<p>var myFunction = new Function(&ldquo;a&rdquo;, &ldquo;b&rdquo;, &ldquo;return a * b&rdquo;);</p>
<p>var x = myFunction(4, 3);</p>
<p>console.log(x);</p>
<p>The new Function() is a call to the constructor which in turn creates and returns a function reference.</p>
<p>Output :</p>
<p>12</p>
<h3 id="36-recursion-and-typescript-functions">36) Recursion and TypeScript Functions</h3>
<p>Recursion is a technique for iterating over an operation by having a function call to itself repeatedly until it arrives at a result. Recursion is best applied when you need to call the same function repeatedly with different parameters from within a loop.</p>
<p>Example – Recursion</p>
<p>function factorial(number) {</p>
<p>if (number &lt;= 0) { // termination case</p>
<p>return 1;</p>
<p>} else {</p>
<p>return (number * factorial(number - 1)); // function invokes itself</p>
<p>}</p>
<p>};</p>
<p>console.log(factorial(6)); // outputs 720</p>
<p>On compiling, it will generate the same code in JavaScript.</p>
<p>Here is its output −</p>
<p>720</p>
<p>Example: Anonymous Recursive Function</p>
<p>(function () {</p>
<p>var x = &ldquo;Hello!!&quot;;</p>
<p>console.log(x)</p>
<p>})() // the function invokes itself using a pair of parentheses ()</p>
<p>On compiling, it will generate the same code in JavaScript.</p>
<p>Output :</p>
<p>Hello!!</p>
<h3 id="37lambda-functions">37) Lambda Functions</h3>
<p>Lambda refers to anonymous functions in programming. Lambda functions are a concise mechanism to represent anonymous functions. These functions are also called as Arrow functions.</p>
<p>Lambda Function - Anatomy</p>
<p>There are 3 parts to a Lambda function −</p>
<ul>
<li>Parameters − A function may optionally have parameters</li>
<li>The fat arrow notation/lambda notation (=&gt;) − It is also called as the goes to operator</li>
<li>Statements − represent the function&rsquo;s instruction set</li>
</ul>
<p>Tip − By convention, the use of single letter parameter is encouraged for a compact and precise function declaration.</p>
<h3 id="38-lambda-expression">38) Lambda Expression</h3>
<p>It is an anonymous function expression that points to a single line of code. Its syntax is as follows −</p>
<p>( [param1, parma2,…param n] )=&gt;statement;</p>
<p>Example: Lambda Expression</p>
<p>var foo = (x:number)=&gt;10 + x</p>
<p>console.log(foo(100)) //outputs 110</p>
<p>The program declares a lambda expression function. The function returns the sum of 10 and the argument passed.</p>
<p>On compiling, it will generate following JavaScript code.</p>
<p>//Generated by typescript 1.8.10</p>
<p>var foo = function (x) { return 10 + x; };</p>
<p>console.log(foo(100)); //outputs 110</p>
<p>Here is the output of the above code −</p>
<p>110</p>
<h3 id="39-syntactic-variations">39) Syntactic Variations</h3>
<p>Parameter type Inference</p>
<p>It is not mandatory to specify the data type of a parameter. In such a case the data type of the parameter is any. Let us take a look at the following code snippet −</p>
<p>var func = (x)=&gt; {</p>
<p>if(typeof x==&quot;number&rdquo;) {</p>
<p>console.log(x+&rdquo; is numeric&rdquo;)</p>
<p>} else if(typeof x==&quot;string&rdquo;) {</p>
<p>console.log(x+&rdquo; is a string&rdquo;)</p>
<p>}</p>
<p>}</p>
<p>func(12)</p>
<p>func(&ldquo;Tom&rdquo;)</p>
<p>Output :</p>
<p>12 is numeric</p>
<p>Tom is a string</p>
<h3 id="40function-overloads">40) Function Overloads</h3>
<p>Functions have the capability to operate differently on the basis of the input provided to them. In other words, a program can have multiple methods with the same name with different implementation. This mechanism is termed as Function Overloading. TypeScript provides support for function overloading.</p>
<p>To overload a function in TypeScript, you need to follow the steps given below −</p>
<p>Step 1 − Declare multiple functions with the same name but different function signature. Function signature includes the following.</p>
<p>(The data type of the parameter)</p>
<p>function disp(string):void;</p>
<p>function disp(number):void;</p>
<p>(The number of parameters)</p>
<p>function disp(n1:number):void;</p>
<p>function disp(x:number,y:number):void;</p>
<p>(The sequence of parameters)</p>
<p>function disp(n1:number,s1:string):void;</p>
<p>function disp(s:string,n:number):void;</p>
<p>Note − The function signature doesn&rsquo;t include the function&rsquo;s return type.</p>
<p>Step 2 − The declaration must be followed by the function definition. The parameter types should be set to any if the parameter types differ during overload. Additionally, for case b explained above, you may consider marking one or more parameters as optional during the function definition.</p>
<p>Step 3 − Finally, you must invoke the function to make it functional.</p>
<p>Example :</p>
<p>Let us now take a look at the following example code −</p>
<p>function disp(s1:string):void;</p>
<p>function disp(n1:number,s1:string):void;</p>
<p>function disp(x:any,y?:any):void {</p>
<p>console.log(x);</p>
<p>console.log(y);</p>
<p>}</p>
<p>disp(&ldquo;abc&rdquo;)</p>
<p>disp(1,&ldquo;xyz&rdquo;);</p>
<p>The first two lines depict the function overload declaration. The function has two overloads −</p>
<p>Function that accepts a single string parameter.</p>
<p>Function that accepts two values of type number and string respectively.</p>
<p>The third line defines the function. The data type of the parameters are set to any. Moreover, the second parameter is optional here.</p>
<p>The overloaded function is invoked by the last two statements.</p>
<p>Output :</p>
<p>abc</p>
<p>1</p>
<p>xyz</p>
<h3 id="41-numbers-in-typescript">41) Numbers in TypeScript</h3>
<p>TypeScript like JavaScript supports numeric values as Number objects. A number object converts numeric literal to an instance of the number class. The Number class acts as a wrapper and enables manipulation of numeric literals as they were objects.</p>
<p>Syntax :</p>
<p>var var_name = new Number(value)</p>
<p>In case a non-numeric argument is passed as an argument to the Number&rsquo;s constructor, it returns NaN (Not–a–Number).</p>
<h3 id="42--number-object-properties">42 ) Number Object properties</h3>
<p>MAX_VALUE - The largest possible value a number in JavaScript can have 1.7976931348623157E+308.</p>
<p>MIN_VALUE - The smallest possible value a number in JavaScript can have 5E-324.</p>
<p>NaN - Equal to a value that is not a number.</p>
<p>NEGATIVE_INFINITY - A value that is less than MIN_VALUE.</p>
<p>POSITIVE_INFINITY - A value that is greater than MAX_VALUE.</p>
<p>Prototype - A static property of the Number object. Use the prototype property to assign new properties and methods to the Number object in the current document.</p>
<p>Constructor - Returns the function that created this object&rsquo;s instance. By default, this is the Number object.</p>
<h2 id="number-methods">Number Methods</h2>
<h3 id="43-toexponential">43 ) toExponential()</h3>
<p>Forces a number to display in exponential notation, even if the number is in the range in which JavaScript normally uses standard notation.</p>
<p>Syntax :</p>
<p>number.toExponential( [fractionDigits] )</p>
<p>Parameter Details :</p>
<p>fractionDigits − An integer specifying the number of digits after the decimal point. Defaults to as many digits as necessary to specify the number.</p>
<p>Return Value :</p>
<p>A string representing a Number object in exponential notation with one digit before the decimal point, rounded to fractionDigits digits after the decimal point. If the fractionDigits argument is omitted, the number of digits after the decimal point defaults to the number of digits necessary to represent the value uniquely.</p>
<p>Example :</p>
<p>//toExponential()</p>
<p>var num1 = 1225.30</p>
<p>var val = num1.toExponential();</p>
<p>console.log(val)</p>
<p>On compiling, it will generate the same code in JavaScript.</p>
<p>Its output is as follows −</p>
<p>1.2253e+3</p>
<h3 id="44-tofixed">44)  toFixed()</h3>
<p>This method formats a number with a specific number of digits to the right of the decimal.</p>
<p>Syntax :</p>
<p>number.toFixed( [digits] )</p>
<p>Parameter Details :</p>
<p>digits − The number of digits to appear after the decimal point.</p>
<p>Return Value :</p>
<p>A string representation of number that does not use exponential notation and has the exact number of digits after the decimal place.</p>
<p>Example :</p>
<p>var num3 = 177.234</p>
<p>console.log(&ldquo;num3.toFixed() is &ldquo;+num3.toFixed())</p>
<p>console.log(&ldquo;num3.toFixed(2) is &ldquo;+num3.toFixed(2))</p>
<p>console.log(&ldquo;num3.toFixed(6) is &ldquo;+num3.toFixed(6))</p>
<p>On compiling, it will generate the same code in JavaScript.</p>
<p>The code will produce the following output −</p>
<p>num3.toFixed() is 177</p>
<p>num3.toFixed(2) is 177.23</p>
<p>num3.toFixed(6) is 177.234000</p>
<h3 id="45-tolocalestring">45) toLocaleString()</h3>
<p>Returns a string value version of the current number in a format that may vary according to a browser&rsquo;s local settings.</p>
<p>This method converts a number object into a human readable string representing the number using the locale of the environment.</p>
<p>Syntax :</p>
<p>number.toLocaleString()</p>
<p>Return Value :</p>
<p>Returns a human readable string representing the number using the locale of the environment.</p>
<p>Example :</p>
<p>var num = new Number(177.1234);</p>
<p>console.log( num.toLocaleString());</p>
<p>On compiling, it will generate the same code in JavaScript.</p>
<p>The code will produce the following output −</p>
<p>177.1234</p>
<h3 id="46-toprecision">46) toPrecision()</h3>
<p>Defines how many total digits (including digits to the left and right of the decimal) to display of a number. A negative precision will throw an error.</p>
<p>This method returns a string representing the number object to the specified precision.</p>
<p>Syntax :</p>
<p>number.toPrecision( [ precision ] )</p>
<p>Parameter Details :</p>
<p>precision − An integer specifying the number of significant digits.</p>
<p>Return Value :</p>
<p>Returns a string representing a Number object in fixed-point or exponential notation rounded to precision significant digits.</p>
<p>Example :</p>
<p>var num = new Number(7.123456);</p>
<p>console.log(num.toPrecision());</p>
<p>console.log(num.toPrecision(1));</p>
<p>console.log(num.toPrecision(2));</p>
<p>On compiling, it will generate the same code in JavaScript.</p>
<p>The code will produce the following output −</p>
<p>7.123456</p>
<p>7</p>
<p>7.1</p>
<h3 id="47-tostring">47) toString()</h3>
<p>Returns the string representation of the number&rsquo;s value. The function is passed the radix, an integer between 2 and 36 specifying the base to use for representing numeric values.</p>
<p>This method returns a string representing the specified object. The toString() method parses its first argument, and attempts to return a string representation in the specified radix (base).</p>
<p>Syntax</p>
<p>number.toString( [radix] )</p>
<p>Parameter Details :</p>
<p>radix − An integer between 2 and 36 specifying the base to use for representing numeric values.</p>
<p>Return Value :</p>
<p>Returns a string representing the specified Number object.</p>
<p>Example :</p>
<p>var num = new Number(10);</p>
<p>console.log(num.toString());</p>
<p>console.log(num.toString(2));</p>
<p>console.log(num.toString(8));</p>
<p>On compiling, it will generate the same code in JavaScript.</p>
<p>The code will produce the following output −</p>
<p>10</p>
<p>1010</p>
<p>12</p>
<h3 id="48-valueof">48) valueOf()</h3>
<p>Returns the number&rsquo;s primitive value.</p>
<p>This method returns the primitive value of the specified number object.</p>
<p>Syntax</p>
<p>number.valueOf()</p>
<p>Return Value :</p>
<p>Returns the primitive value of the specified number object.</p>
<p>Example :</p>
<p>var num = new Number(10);</p>
<p>console.log(num.valueOf());</p>
<p>On compiling, it will generate the same code in JavaScript.</p>
<p>The code will produce the following output −</p>
<p>10</p>
<h3 id="49-typescript---strings">49) TypeScript - Strings</h3>
<p>The String object lets you work with a series of characters. It wraps the string primitive data type with a number of helper methods.</p>
<p>Syntax :</p>
<p>var var_name = new String(string);</p>
<p>A list of the methods available in String object along with their description is given below −</p>
<p>1. Constructor</p>
<p>Returns a reference to the String function that created the object.</p>
<p>2. Length</p>
<p>Returns the length of the string.</p>
<p>3. Prototype</p>
<p>The prototype property allows you to add properties and methods to an object.</p>
<h3 id="50-string-methods">50 ) String Methods</h3>
<p>A list of the methods available in String object along with their description is given below −</p>
<p>1. charAt() - Returns the character at the specified index.</p>
<p>2. charCodeAt() - Returns a number indicating the Unicode value of the character at the given index.</p>
<p>3. concat() - Combines the text of two strings and returns a new string.</p>
<p>4. indexOf() - Returns the index within the calling String object of the first occurrence of the specified value, or -1 if not found.</p>
<p>5. lastIndexOf() - Returns the index within the calling String object of the last occurrence of the specified value, or -1 if not found.</p>
<p>6. localeCompare() - Returns a number indicating whether a reference string comes before or after or is the same as the given string in sort order.</p>
<p>7. match() - Used to match a regular expression against a string.</p>
<p>8. replace() - Used to find a match between a regular expression and a string, and to replace the matched substring with a new substring.</p>
<p>9. search() - Executes the search for a match between a regular expression and a specified string.</p>
<p>10. slice() - Extracts a section of a string and returns a new string.</p>
<p>11. split() - Splits a String object into an array of strings by separating the string into substrings.</p>
<p>12. substr() - Returns the characters in a string beginning at the specified location through the specified number of characters.</p>
<p>13. substring() - Returns the characters in a string between two indexes into the string.</p>
<p>14. toLocaleLowerCase() - The characters within a string are converted to lower case while respecting the current locale.</p>
<p>15. toLocaleUpperCase() - The characters within a string are converted to upper case while respecting the current locale.</p>
<p>16. toLowerCase() - Returns the calling string value converted to lower case.</p>
<p>17. toString() - Returns a string representing the specified object.</p>
<p>18. toUpperCase() - Returns the calling string value converted to uppercase.</p>
<p>19. valueOf() - Returns the primitive value of the specified object.</p>
<h3 id="51-declaring-and-initializing-arrays">51) Declaring and Initializing Arrays</h3>
<p>To declare an initialize an array in Typescript use the following syntax −</p>
<p>Syntax :</p>
<p>var array_name[:datatype]; //declaration</p>
<p>array_name = [val1,val2,valn..] //initialization</p>
<p>An array declaration without the data type is deemed to be of the type any. The type of such an array is inferred from the data type of the array&rsquo;s first element during initialization.</p>
<p>Arrays may be declared and initialized in a single statement. The syntax for the same is −</p>
<p>var array_name[:data type] = [val1,val2…valn]</p>
<h3 id="52-accessing-array-elements">52) Accessing Array Elements</h3>
<p>The array name followed by the subscript is used refer to an array element. Its syntax is as follows −</p>
<p>array_name[subscript] = value</p>
<p>Example: Simple Array</p>
<p>var alphas:string[];</p>
<p>alphas = [&ldquo;1&rdquo;,&ldquo;2&rdquo;,&ldquo;3&rdquo;,&ldquo;4&rdquo;]</p>
<p>console.log(alphas[0]);</p>
<p>console.log(alphas[1]);</p>
<p>The output of the above code is as follows −</p>
<p>1</p>
<p>2</p>
<h3 id="53array-object">53) Array Object</h3>
<p>An array can also be created using the Array object. The Array constructor can be passed.</p>
<p>A numeric value that represents the size of the array or a list of comma separated values.</p>
<p>The following example shows how to create an array using this method.</p>
<p>Example :</p>
<p>var arr_names:number[] = new Array(4)</p>
<p>for(var i = 0;i&lt;arr_names.length;i++) {</p>
<p>arr_names[i] = i * 2</p>
<p>console.log(arr_names[i])</p>
<p>}</p>
<h3 id="54array-constructor-accepts-comma-separated-values">54) Array Constructor accepts comma separated values</h3>
<p>Example:</p>
<p>var names:string[] = new Array(&ldquo;Mary&rdquo;,&ldquo;Tom&rdquo;,&ldquo;Jack&rdquo;,&ldquo;Jill&rdquo;)</p>
<p>for(var i = 0;i&lt;names.length;i++) {</p>
<p>console.log(names[i])</p>
<p>}</p>
<p>Its output is as follows −</p>
<p>Mary</p>
<p>Tom</p>
<p>Jack</p>
<p>Jill</p>
<h3 id="55array-methods-in-typescript">55) Array Methods in TypeScript</h3>
<p>A list of the methods of the Array object along with their description is given below.</p>
<p>1. concat()</p>
<p>Returns a new array comprised of this array joined with other array(s) and/or value(s).</p>
<p>2. every()</p>
<p>Returns true if every element in this array satisfies the provided testing function.</p>
<p>3. filter()</p>
<p>Creates a new array with all of the elements of this array for which the provided filtering function returns true.</p>
<p>4. forEach()</p>
<p>Calls a function for each element in the array.</p>
<p>5. indexOf()</p>
<p>Returns the first (least) index of an element within the array equal to the specified value, or -1 if none is found.</p>
<p>6. join()</p>
<p>Joins all elements of an array into a string.</p>
<p>7. lastIndexOf()</p>
<p>Returns the last (greatest) index of an element within the array equal to the specified value, or -1 if none is found.</p>
<p>8. map()</p>
<p>Creates a new array with the results of calling a provided function on every element in this array.</p>
<p>9. pop()</p>
<p>Removes the last element from an array and returns that element.</p>
<p>10. push()</p>
<p>Adds one or more elements to the end of an array and returns the new length of the array.</p>
<p>11. reduce()</p>
<p>Apply a function simultaneously against two values of the array (from left-to-right) as to reduce it to a single value.</p>
<p>12. reduceRight()</p>
<p>Apply a function simultaneously against two values of the array (from right-to-left) as to reduce it to a single value.</p>
<p>13. reverse()</p>
<p>Reverses the order of the elements of an array &ndash; the first becomes the last, and the last becomes the first.</p>
<p>14. shift()</p>
<p>Removes the first element from an array and returns that element.</p>
<p>15. slice()</p>
<p>Extracts a section of an array and returns a new array.</p>
<p>16. some()</p>
<p>Returns true if at least one element in this array satisfies the provided testing function.</p>
<p>17. sort()</p>
<p>Sorts the elements of an array.</p>
<p>18. splice()</p>
<p>Adds and/or removes elements from an array.</p>
<p>19. toString()</p>
<p>Returns a string representing the array and its elements.</p>
<p>20. unshift()</p>
<p>Adds one or more elements to the front of an array and returns the new length of the array.</p>
<h3 id="56array-destructuring">56) Array Destructuring</h3>
<p>Refers to breaking up the structure of an entity. TypeScript supports destructuring when used in the context of an array.</p>
<p>Example :</p>
<p>var arr:number[] = [12,13]</p>
<p>var[x,y] = arr</p>
<p>console.log(x)</p>
<p>console.log(y)</p>
<p>Its output is as follows −</p>
<p>12</p>
<p>13</p>
<h3 id="57array-traversal-using-forin-loop">57) Array Traversal using for…in loop</h3>
<p>One can use the for…in loop to traverse through an array.</p>
<p>var j:any;</p>
<p>var nums:number[] = [1001,1002,1003,1004]</p>
<p>for(j in nums) {</p>
<p>console.log(nums[j])</p>
<p>}</p>
<p>The loop performs an index based array traversal.</p>
<p>On compiling, it will generate following JavaScript code.</p>
<p>//Generated by typescript 1.8.10</p>
<p>var j;</p>
<p>var nums = [1001, 1002, 1003, 1004];</p>
<p>for (j in nums) {</p>
<p>console.log(nums[j]);</p>
<p>}</p>
<p>The output of the above code is given below −</p>
<p>1001</p>
<p>1002</p>
<p>1003</p>
<p>1004</p>
<h3 id="58-arrays-in-typescript">58) Arrays in TypeScript</h3>
<p>TypeScript supports the following concepts in arrays −</p>
<p>1. Multi-dimensional arrays</p>
<p>TypeScript supports multidimensional arrays. The simplest form of the multidimensional array is the twodimensional array.</p>
<p>2. Passing arrays to functions</p>
<p>You can pass to the function a pointer to an array by specifying the array&rsquo;s name without an index.</p>
<p>3. Return array from functions</p>
<p>Allows a function to return an array</p>
<h2 id="typescript---classes">TypeScript - Classes</h2>
<h3 id="59creating-classes">59) Creating classes</h3>
<p>TypeScript is object oriented JavaScript. TypeScript supports object-oriented programming features like classes, interfaces, etc. A class in terms of OOP is a blueprint for creating objects. A class encapsulates data for the object. Typescript gives built in support for this concept called class. JavaScript ES5 or earlier didn&rsquo;t support classes. Typescript gets this feature from ES6.</p>
<p>Use the class keyword to declare a class in TypeScript. The syntax for the same is given below −</p>
<p>Syntax :</p>
<p>class class_name {</p>
<p>//class scope</p>
<p>}</p>
<p>The class keyword is followed by the class name. The rules for identifiers must be considered while naming a class.</p>
<p>A class definition can include the following −</p>
<p>Fields − A field is any variable declared in a class. Fields represent data pertaining to objects</p>
<p>Constructors − Responsible for allocating memory for the objects of the class</p>
<p>Functions − Functions represent actions an object can take. They are also at times referred to as methods</p>
<p>These components put together are termed as the data members of the class.</p>
<p>Consider a class Person in typescript.</p>
<p>class Person {</p>
<p>}</p>
<p>On compiling, it will generate following JavaScript code.</p>
<p>//Generated by typescript 1.8.10</p>
<p>var Person = (function () {</p>
<p>function Person() {</p>
<p>}</p>
<p>return Person;</p>
<p>}());</p>
<p>Example: Declaring a class</p>
<p>class Car {</p>
<p>//field</p>
<p>engine:string;</p>
<p>//constructor</p>
<p>constructor(engine:string) {</p>
<p>this.engine = engine</p>
<p>}</p>
<p>//function</p>
<p>disp():void {</p>
<p>console.log(&ldquo;Engine is : &ldquo;+this.engine)</p>
<p>}</p>
<p>}</p>
<p>The example declares a class Car. The class has a field named engine. The var keyword is not used while declaring a field. The example above declares a constructor for the class.</p>
<p>A constructor is a special function of the class that is responsible for initializing the variables of the class. TypeScript defines a constructor using the constructor keyword. A constructor is a function and hence can be parameterized.</p>
<p>The this keyword refers to the current instance of the class. Here, the parameter name and the name of the class&rsquo;s field are the same. Hence to avoid ambiguity, the class&rsquo;s field is prefixed with the this keyword.</p>
<p>disp() is a simple function definition. Note that the function keyword is not used here.</p>
<h3 id="60creating-instance-objects">60) Creating Instance objects</h3>
<p>To create an instance of the class, use the new keyword followed by the class name. The syntax for the same is given below −</p>
<p>Syntax :</p>
<p>var object_name = new class_name([ arguments ])</p>
<p>The new keyword is responsible for instantiation.</p>
<p>The right-hand side of the expression invokes the constructor. The constructor should be passed values if it is parameterized.</p>
<p>Example: Instantiating a class</p>
<p>var obj = new Car(&ldquo;Engine 1&rdquo;)</p>
<h3 id="61-accessing-attributes-and-functions">61) Accessing Attributes and Functions</h3>
<p>A class&rsquo;s attributes and functions can be accessed through the object. Use the ‘ . ’ dot notation (called as the period) to access the data members of a class.</p>
<p>//accessing an attribute</p>
<p>obj.field_name</p>
<p>//accessing a function</p>
<p>obj.function_name()</p>
<p>Example: Putting them together</p>
<p>class Car {</p>
<p>//field</p>
<p>engine:string;</p>
<p>//constructor</p>
<p>constructor(engine:string) {</p>
<p>this.engine = engine</p>
<p>}</p>
<p>//function</p>
<p>disp():void {</p>
<p>console.log(&ldquo;Function displays Engine is : &ldquo;+this.engine)</p>
<p>}</p>
<p>}</p>
<p>//create an object</p>
<p>var obj = new Car(&ldquo;XXSY1&rdquo;)</p>
<p>//access the field</p>
<p>console.log(&ldquo;Reading attribute value Engine as : &ldquo;+obj.engine)</p>
<p>//access the function</p>
<p>obj.disp()</p>
<p>Output :</p>
<p>Reading attribute value Engine as : XXSY1</p>
<p>Function displays Engine is : XXSY1</p>
<h3 id="62-class-inheritance">62) Class Inheritance</h3>
<p>TypeScript supports the concept of Inheritance. Inheritance is the ability of a program to create new classes from an existing class. The class that is extended to create newer classes is called the parent class/super class. The newly created classes are called the child/sub classes.</p>
<p>A class inherits from another class using the &lsquo;extends&rsquo; keyword. Child classes inherit all properties and methods except private members and constructors from the parent class.</p>
<p>Syntax :</p>
<p>class child_class_name extends parent_class_name</p>
<p>However, TypeScript doesn&rsquo;t support multiple inheritance.</p>
<p>Inheritance can be classified as −</p>
<ul>
<li>Single − Every class can at the most extend from one parent class</li>
<li>Multiple − A class can inherit from multiple classes. TypeScript doesn’t support multiple inheritance.</li>
<li>Multi-level − The following example shows how multi-level inheritance works.</li>
</ul>
<h3 id="63-class-inheritance-example">63)  Class Inheritance example</h3>
<p>class Shape {</p>
<p>Area:number</p>
<p>constructor(a:number) {</p>
<p>this.Area = a</p>
<p>}</p>
<p>}</p>
<p>class Circle extends Shape {</p>
<p>disp():void {</p>
<p>console.log(&ldquo;Area of the circle: &ldquo;+this.Area)</p>
<p>}</p>
<p>}</p>
<p>var obj = new Circle(223);</p>
<p>obj.disp()</p>
<p>The output of the above code is as follows −</p>
<p>Area of the Circle: 223</p>
<p>Example 2:</p>
<p>class Root {</p>
<p>str:string;</p>
<p>}</p>
<p>class Child extends Root {}</p>
<p>class Leaf extends Child {} //indirectly inherits from Root by virtue of inheritance</p>
<p>var obj = new Leaf();</p>
<p>obj.str =&quot;hello&rdquo;</p>
<p>console.log(obj.str)</p>
<p>Output : hello</p>
<h3 id="64typescript--class-inheritance-and-method-overriding">64) TypeScript ─ Class inheritance and Method Overriding</h3>
<p>Method Overriding is a mechanism by which the child class redefines the superclass&rsquo;s method. The following example illustrates the same −</p>
<p>class PrinterClass {</p>
<p>doPrint():void {</p>
<p>console.log(&ldquo;doPrint() from Parent called…&quot;)</p>
<p>}</p>
<p>}</p>
<p>class StringPrinter extends PrinterClass {</p>
<p>doPrint():void {</p>
<p>super.doPrint()</p>
<p>console.log(&ldquo;doPrint() is printing a string…&quot;)</p>
<p>}</p>
<p>}</p>
<p>var obj = new StringPrinter()</p>
<p>obj.doPrint()</p>
<p>The super keyword is used to refer to the immediate parent of a class. The keyword can be used to refer to the super class version of a variable, property or method. Line 13 invokes the super class version of the doWork() function.</p>
<p>Output :</p>
<p>doPrint() from Parent called…</p>
<p>doPrint() is printing a string…</p>
<h3 id="65the-static-keyword">65) The static Keyword</h3>
<p>The static keyword can be applied to the data members of a class. A static variable retains its values till the program finishes execution. Static members are referenced by the class name.</p>
<p>Example</p>
<p>class StaticMem {</p>
<p>static num:number;</p>
<p>static disp():void {</p>
<p>console.log(&ldquo;The value of num is&quot;+ StaticMem.num)</p>
<p>}</p>
<p>}</p>
<p>StaticMem.num = 12 // initialize the static variable</p>
<p>StaticMem.disp() // invoke the static method</p>
<p>The output of the above code is as follows −</p>
<p>The value of num is 12</p>
<h3 id="66the-instanceof-operator">66) The instanceof operator</h3>
<p>The instanceof operator returns true if the object belongs to the specified type.</p>
<p>Example :</p>
<p>class Person{ }</p>
<p>var obj = new Person()</p>
<p>var isPerson = obj instanceof Person;</p>
<p>console.log(&rdquo; obj is an instance of Person &quot; + isPerson);</p>
<p>On compiling, it will generate following JavaScript code.</p>
<p>//Generated by typescript 1.8.10</p>
<p>var Person = (function () {</p>
<p>function Person() {</p>
<p>}</p>
<p>return Person;</p>
<p>}());</p>
<p>var obj = new Person();</p>
<p>var isPerson = obj instanceof Person;</p>
<p>console.log(&rdquo; obj is an instance of Person &quot; + isPerson);</p>
<p>The output of the above code is as follows −</p>
<p>obj is an instance of Person True</p>
<h3 id="67data-hiding">67) Data Hiding</h3>
<p>A class can control the visibility of its data members to members of other classes. This capability is termed as Data Hiding or Encapsulation.</p>
<p>Object Orientation uses the concept of access modifiers or access specifiers to implement the concept of Encapsulation. The access specifiers/modifiers define the visibility of a class&rsquo;s data members outside its defining class.</p>
<p>The access modifiers supported by TypeScript are −</p>
<p>1.public - A public data member has universal accessibility. Data members in a class are public by default.</p>
<p>2.private - Private data members are accessible only within the class that defines these members. If an external class member tries to access a private member, the compiler throws an error.</p>
<p>3.protected - A protected data member is accessible by the members within the same class as that of the former and also by the members of the child classes.</p>
<p>Example :</p>
<p>Let us now take an example to see how data hiding works −</p>
<p>class Encapsulate {</p>
<p>str:string = &ldquo;hello&rdquo;</p>
<p>private str2:string = &ldquo;world&rdquo;</p>
<p>}</p>
<p>var obj = new Encapsulate()</p>
<p>console.log(obj.str) //accessible</p>
<p>console.log(obj.str2) //compilation Error as str2 is private</p>
<p>The class has two string attributes, str1 and str2, which are public and private members respectively. The class is instantiated. The example returns a compile time error, as the private attribute str2 is accessed outside the class that declares it.</p>
<h3 id="68classes-and-interfaces">68) Classes and Interfaces</h3>
<p>Classes can also implement interfaces.</p>
<p>interface ILoan {</p>
<p>interest:number</p>
<p>}</p>
<p>class AgriLoan implements ILoan {</p>
<p>interest:number</p>
<p>rebate:number</p>
<p>constructor(interest:number,rebate:number) {</p>
<p>this.interest = interest</p>
<p>this.rebate = rebate</p>
<p>}</p>
<p>}</p>
<p>var obj = new AgriLoan(10,1)</p>
<p>console.log(&ldquo;Interest is : &ldquo;+obj.interest+&rdquo; Rebate is : &ldquo;+obj.rebate )</p>
<p>The class AgriLoan implements the interface Loan. Hence, it is now binding on the class to include the property interest as its member.</p>
<p>The output of the above code is as follows −</p>
<p>Interest is : 10 Rebate is : 1</p>
<h2 id="interfaces">Interfaces</h2>
<h3 id="69-typescript-interfaces">69)  TypeScript Interfaces</h3>
<p>An interface is a syntactical contract that an entity should conform to. In other words, an interface defines the syntax that any entity must adhere to.</p>
<p>Interfaces define properties, methods, and events, which are the members of the interface. Interfaces contain only the declaration of the members. It is the responsibility of the deriving class to define the members. It often helps in providing a standard structure that the deriving classes would follow.</p>
<p>Let&rsquo;s consider an object −</p>
<p>var person = {</p>
<p>FirstName:&ldquo;Tom&rdquo;,</p>
<p>LastName:&ldquo;Hanks&rdquo;,</p>
<p>sayHi: ()=&gt;{ return &ldquo;Hi&rdquo;}</p>
<p>};</p>
<p>If we consider the signature of the object, it could be −</p>
<p>{</p>
<p>FirstName:string,</p>
<p>LastName:string,</p>
<p>sayHi()=&gt;string</p>
<p>}</p>
<p>To reuse the signature across objects we can define it as an interface.</p>
<p>Declaring Interfaces :</p>
<p>The interface keyword is used to declare an interface. Here is the syntax to declare an interface −</p>
<p>Syntax :</p>
<p>interface interface_name {</p>
<p>}</p>
<p>Interfaces are not to be converted to JavaScript. It’s just part of TypeScript. If you see the screen shot of TS Playground tool there is no java script emitted when you declare an interface unlike a class. So interfaces have zero runtime JavaScript impact</p>
<h3 id="70-union-type-and-interface">70) Union Type and Interface</h3>
<p>The following example shows the use of Union Type and Interface −</p>
<p>interface RunOptions {</p>
<p>program:string;</p>
<p>commandline:string[]|string|(()=&gt;string);</p>
<p>}</p>
<p>//commandline as string</p>
<p>var options:RunOptions = {program:&ldquo;test1&rdquo;,commandline:&ldquo;Hello&rdquo;};</p>
<p>console.log(options.commandline)</p>
<p>//commandline as a string array</p>
<p>options = {program:&ldquo;test1&rdquo;,commandline:[&ldquo;Hello&rdquo;,&ldquo;World&rdquo;]};</p>
<p>console.log(options.commandline[0]);</p>
<p>console.log(options.commandline[1]);</p>
<p>//commandline as a function expression</p>
<p>options = {program:&ldquo;test1&rdquo;,commandline:()=&gt;{return &ldquo;**Hello World**&quot;;}};</p>
<p>var fn:any = options.commandline;</p>
<p>console.log(fn());</p>
<p>On compiling, it will generate following JavaScript code.</p>
<p>//Generated by typescript 1.8.10</p>
<p>//commandline as string</p>
<p>var options = { program: &ldquo;test1&rdquo;, commandline: &ldquo;Hello&rdquo; };</p>
<p>console.log(options.commandline);</p>
<p>//commandline as a string array</p>
<p>options = { program: &ldquo;test1&rdquo;, commandline: [&ldquo;Hello&rdquo;, &ldquo;World&rdquo;] };</p>
<p>console.log(options.commandline[0]);</p>
<p>console.log(options.commandline[1]);</p>
<p>//commandline as a function expression</p>
<p>options = { program: &ldquo;test1&rdquo;, commandline: function () { return &ldquo;**Hello World**&quot;; } };</p>
<p>var fn = options.commandline;</p>
<p>console.log(fn());</p>
<p>Its output is as follows −</p>
<p>Hello</p>
<p>Hello</p>
<p>World</p>
<p>**Hello World**</p>
<h3 id="71interfaces-and-arrays">71) Interfaces and Arrays</h3>
<p>Interface can define both the kind of key an array uses and the type of entry it contains. Index can be of type string or type number.</p>
<p>Example :</p>
<p>interface namelist {</p>
<p>[index:number]:string</p>
<p>}</p>
<p>var list2:namelist = [&ldquo;John&rdquo;,1,&ldquo;Bran&rdquo;] //Error. 1 is not type string</p>
<p>interface ages {</p>
<p>[index:string]:number</p>
<p>}</p>
<p>var agelist:ages;</p>
<p>agelist[&ldquo;John&rdquo;] = 15 // Ok</p>
<p>agelist[2] = &ldquo;nine&rdquo; // Error</p>
<h3 id="72interfaces-and-inheritance">72) Interfaces and Inheritance</h3>
<p>An interface can be extended by other interfaces. In other words, an interface can inherit from other interface. Typescript allows an interface to inherit from multiple interfaces.</p>
<p>Use the extends keyword to implement inheritance among interfaces.</p>
<p>Syntax: Single Interface Inheritance :</p>
<p>Child_interface_name extends super_interface_name</p>
<p>Syntax: Multiple Interface Inheritance :</p>
<p>Child_interface_name extends super_interface1_name,</p>
<p>super_interface2_name,…,super_interfaceN_name</p>
<p>Example: Simple Interface Inheritance</p>
<p>interface Person {</p>
<p>age:number</p>
<p>}</p>
<p>interface Musician extends Person {</p>
<p>instrument:string</p>
<p>}</p>
<p>var drummer = &lt;Musician&gt;{};</p>
<p>drummer.age = 27</p>
<p>drummer.instrument = &ldquo;Drums&rdquo;</p>
<p>console.log(&ldquo;Age: &ldquo;+drummer.age) console.log(&ldquo;Instrument: &ldquo;+drummer.instrument)</p>
<p>On compiling, it will generate following JavaScript code.</p>
<p>//Generated by typescript 1.8.10</p>
<p>var drummer = {};</p>
<p>drummer.age = 27;</p>
<p>drummer.instrument = &ldquo;Drums&rdquo;;</p>
<p>console.log(&ldquo;Age: &quot; + drummer.age);</p>
<p>console.log(&ldquo;Instrument: &quot; + drummer.instrument);</p>
<p>Its output is as follows −</p>
<p>Age: 27</p>
<p>Instrument: Drums</p>
<h3 id="73multiple-interface-inheritance">73) Multiple Interface Inheritance</h3>
<p>Example:</p>
<p>interface IParent1 {</p>
<p>v1:number</p>
<p>}</p>
<p>interface IParent2 {</p>
<p>v2:number</p>
<p>}</p>
<p>interface Child extends IParent1, IParent2 { }</p>
<p>var Iobj:Child = { v1:12, v2:23}</p>
<p>console.log(&ldquo;value 1: &ldquo;+this.v1+&rdquo; value 2: &ldquo;+this.v2)</p>
<p>The object Iobj is of the type interface leaf. The interface leaf by the virtue of inheritance now has two attributes- v1 and v2 respectively. Hence, the object Iobj must now contain these attributes.</p>
<p>On compiling, it will generate following JavaScript code.</p>
<p>//Generated by typescript 1.8.10</p>
<p>var Iobj = { v1: 12, v2: 23 };</p>
<p>console.log(&ldquo;value 1: &quot; + this.v1 + &quot; value 2: &quot; + this.v2);</p>
<p>The output of the above code is as follows −</p>
<p>value 1: 12 value 2: 23</p>
<h2 id="objects">Objects</h2>
<h3 id="74-objects---typescript">74) Objects - TypeScript</h3>
<p>An object is an instance which contains set of key value pairs. The values can be scalar values or functions or even array of other objects. The syntax is given below −</p>
<p>Syntax :</p>
<p>var object_name = {</p>
<p>key1: &ldquo;value1&rdquo;, //scalar value</p>
<p>key2: &ldquo;value&rdquo;,</p>
<p>key3: function() {</p>
<p>//functions</p>
<p>},</p>
<p>key4:[&ldquo;content1&rdquo;, &ldquo;content2&rdquo;] //collection</p>
<p>};</p>
<p>As shown above, an object can contain scalar values, functions and structures like arrays and tuples.</p>
<p>Example: Object Literal Notation</p>
<p>var person = {</p>
<p>firstname:&ldquo;Tom&rdquo;,</p>
<p>lastname:&ldquo;Hanks&rdquo;</p>
<p>};</p>
<p>//access the object values</p>
<p>console.log(person.firstname)</p>
<p>console.log(person.lastname)</p>
<p>On compiling, it will generate the same code in JavaScript.</p>
<p>The output of the above code is as follows −</p>
<p>Tom</p>
<p>Hanks</p>
<h3 id="75typescript-type-template">75) TypeScript Type Template</h3>
<p>Let&rsquo;s say you created an object literal in JavaScript as −</p>
<p>var person = {</p>
<p>firstname:&ldquo;Tom&rdquo;,</p>
<p>lastname:&ldquo;Hanks&rdquo;</p>
<p>};</p>
<p>In case you want to add some value to an object, JavaScript allows you to make the necessary modification. Suppose we need to add a function to the person object later this is the way you can do this.</p>
<p>person.sayHello = function(){ return &ldquo;hello&rdquo;;}</p>
<p>If you use the same code in Typescript the compiler gives an error. This is because in Typescript, concrete objects should have a type template. Objects in Typescript must be an instance of a particular type.</p>
<p>You can solve this by using a method template in declaration.</p>
<p>Example: Typescript Type template</p>
<p>var person = {</p>
<p>firstName:&ldquo;Tom&rdquo;,</p>
<p>lastName:&ldquo;Hanks&rdquo;,</p>
<p>sayHello:function() { } //Type template</p>
<p>}</p>
<p>person.sayHello = function() {</p>
<p>console.log(&ldquo;hello &ldquo;+person.firstName)</p>
<p>}</p>
<p>person.sayHello()</p>
<p>On compiling, it will generate the same code in JavaScript.</p>
<p>The output of the above code is as follows −</p>
<p>hello Tom</p>
<h3 id="76objects-as-function-parameters">76) Objects as function parameters</h3>
<p>Objects can also be passed as parameters to function.</p>
<p>Example:</p>
<p>var person = {</p>
<p>firstname:&ldquo;Tom&rdquo;,</p>
<p>lastname:&ldquo;Hanks&rdquo;</p>
<p>};</p>
<p>var invokeperson = function(obj: { firstname:string, lastname :string }) {</p>
<p>console.log(&ldquo;first name :&ldquo;+obj.firstname)</p>
<p>console.log(&ldquo;last name :&ldquo;+obj.lastname)</p>
<p>}</p>
<p>invokeperson(person)</p>
<p>The example declares an object literal. The function expression is invoked passing person object.</p>
<p>On compiling, it will generate following JavaScript code.</p>
<p>//Generated by typescript 1.8.10</p>
<p>var person = {</p>
<p>firstname: &ldquo;Tom&rdquo;,</p>
<p>lastname: &ldquo;Hanks&rdquo;</p>
<p>};</p>
<p>var invokeperson = function (obj) {</p>
<p>console.log(&ldquo;first name :&rdquo; + obj.firstname);</p>
<p>console.log(&ldquo;last name :&rdquo; + obj.lastname);</p>
<p>};</p>
<p>invokeperson(person);</p>
<p>Its output is as follows −</p>
<p>first name :Tom</p>
<p>last name :Hanks</p>
<h3 id="77anonymous-object">77) Anonymous Object</h3>
<p>You can create and pass an anonymous object on the fly.</p>
<p>Example:</p>
<p>var invokeperson = function(obj:{ firstname:string, lastname :string}) {</p>
<p>console.log(&ldquo;first name :&ldquo;+obj.firstname)</p>
<p>console.log(&ldquo;last name :&ldquo;+obj.lastname)</p>
<p>}</p>
<p>invokeperson({firstname:&ldquo;Sachin&rdquo;,lastname:&ldquo;Tendulkar&rdquo;});</p>
<p>On compiling, it will generate following JavaScript code.</p>
<p>//Generated by typescript 1.8.10</p>
<p>var invokeperson = function (obj) {</p>
<p>console.log(&ldquo;first name :&rdquo; + obj.firstname);</p>
<p>console.log(&ldquo;last name :&rdquo; + obj.lastname);</p>
<p>};</p>
<p>invokeperson({ firstname: &ldquo;Sachin&rdquo;, lastname: &ldquo;Tendulkar&rdquo; });</p>
<p>invokeperson({ firstname: &ldquo;Sachin&rdquo;, lastname: &ldquo;Tendulkar&rdquo; });</p>
<p>Its output is as follows −</p>
<p>first name :Sachin</p>
<p>last name :Tendulkar</p>
<h3 id="78-duck-typing">78) Duck-typing</h3>
<p>In duck-typing, two objects are considered to be of the same type if both share the same set of properties. Duck-typing verifies the presence of certain properties in the objects, rather than their actual type, to check their suitability. The concept is generally explained by the following phrase −</p>
<p>&ldquo;When I see a bird that walks like a duck and swims like a duck and quacks like a duck, I call that bird a duck.&rdquo;</p>
<p>The TypeScript compiler implements the duck-typing system that allows object creation on the fly while keeping type safety. The following example shows how we can pass objects that don&rsquo;t explicitly implement an interface but contain all of the required members to a function.</p>
<p>Example :</p>
<p>interface IPoint {</p>
<p>x:number</p>
<p>y:number</p>
<p>}</p>
<p>function addPoints(p1:IPoint,p2:IPoint):IPoint {</p>
<p>var x = p1.x + p2.x</p>
<p>var y = p1.y + p2.y</p>
<p>return {x:x,y:y}</p>
<p>}</p>
<p>//Valid</p>
<p>var newPoint = addPoints({x:3,y:4},{x:5,y:1})</p>
<p>//Error</p>
<p>var newPoint2 = addPoints({x:1},{x:4,y:3})</p>
<h3 id="tuples">Tuples</h3>
<h3 id="79-typescript-tuples">79) TypeScript Tuples</h3>
<p>At times, there might be a need to store a collection of values of varied types. Arrays will not serve this purpose. TypeScript gives us a data type called tuple that helps to achieve such a purpose.</p>
<p>It represents a heterogeneous collection of values. In other words, tuples enable storing multiple fields of different types. Tuples can also be passed as parameters to functions.</p>
<p>Syntax :</p>
<p>var tuple_name = [value1,value2,value3,…value n]</p>
<p>For Example</p>
<p>var mytuple = [10,&ldquo;Hello&rdquo;];</p>
<p>You can also declare an empty tuple in Typescript and choose to initialize it later.</p>
<p>var mytuple = [];</p>
<p>mytuple[0] = 120</p>
<p>mytuple[1] = 234</p>
<h2 id="80accessing-values-in-tuples">80) Accessing values in Tuples</h2>
<p>Tuple values are individually called items. Tuples are index based. This means that items in a tuple can be accessed using their corresponding numeric index. Tuple item&rsquo;s index starts from zero and extends up to n-1(where n is the tuple&rsquo;s size).</p>
<p>Syntax :</p>
<p>tuple_name[index]</p>
<p>Example: Simple Tuple</p>
<p>var mytuple = [10,&ldquo;Hello&rdquo;]; //create a tuple</p>
<p>console.log(mytuple[0])</p>
<p>console.log(mytuple[1])</p>
<p>In the above example, a tuple, mytuple, is declared. The tuple contains values of numeric and string types respectively.</p>
<p>On compiling, it will generate the same code in JavaScript.</p>
<p>Its output is as follows −</p>
<p>10</p>
<p>Hello</p>
<p>Example: Empty Tuple</p>
<p>var tup = []</p>
<p>tup[0] = 12</p>
<p>tup[1] = 23</p>
<p>console.log(tup[0])</p>
<p>console.log(tup[1])</p>
<p>On compiling, it will generate the same code in JavaScript.</p>
<p>Its output is as follows −</p>
<p>12</p>
<p>23</p>
<h3 id="81tuple-operations">81) Tuple Operations</h3>
<p>Tuples in TypeScript supports various operations like pushing a new item, removing an item from the tuple, etc.</p>
<p>Example</p>
<p>var mytuple = [10,&ldquo;Hello&rdquo;,&ldquo;World&rdquo;,&ldquo;typeScript&rdquo;];</p>
<p>console.log(&ldquo;Items before push &ldquo;+mytuple.length) // returns the tuple size</p>
<p>mytuple.push(12) // append value to the tuple</p>
<p>console.log(&ldquo;Items after push &ldquo;+mytuple.length)</p>
<p>console.log(&ldquo;Items before pop &ldquo;+mytuple.length)</p>
<p>console.log(mytuple.pop()+&rdquo; popped from the tuple&rdquo;) // removes and returns the last item</p>
<p>console.log(&ldquo;Items after pop &ldquo;+mytuple.length)</p>
<ul>
<li>The push() appends an item to the tuple</li>
<li>The pop() removes and returns the last value in the tuple</li>
</ul>
<p>On compiling, it will generate the same code in JavaScript.</p>
<p>The output of the above code is as follows −</p>
<p>Items before push 4</p>
<p>Items after push 5</p>
<p>Items before pop 5</p>
<p>12 popped from the tuple</p>
<p>Items after pop 4</p>
<h3 id="82updating-tuples">82) Updating Tuples</h3>
<p>Tuples are mutable which means you can update or change the values of tuple elements.</p>
<p>Example</p>
<p>var mytuple = [10,&ldquo;Hello&rdquo;,&ldquo;World&rdquo;,&ldquo;typeScript&rdquo;]; //create a tuple</p>
<p>console.log(&ldquo;Tuple value at index 0 &ldquo;+mytuple[0])</p>
<p>//update a tuple element</p>
<p>mytuple[0] = 121</p>
<p>console.log(&ldquo;Tuple value at index 0 changed to &ldquo;+mytuple[0])</p>
<p>On compiling, it will generate the same code in JavaScript.</p>
<p>The output of the above code is as follows −</p>
<p>Tuple value at index 0 10</p>
<p>Tuple value at index 0 changed to 121</p>
<h3 id="83destructuring-a-tuple">83) Destructuring a Tuple</h3>
<p>Destructuring refers to breaking up the structure of an entity. TypeScript supports destructuring when used in the context of a tuple.</p>
<p>Example</p>
<p>var a =[10,&ldquo;hello&rdquo;]</p>
<p>var [b,c] = a</p>
<p>console.log( b )</p>
<p>console.log( c )</p>
<p>On compiling, it will generate following JavaScript code.</p>
<p>//Generated by typescript 1.8.10</p>
<p>var a = [10, &ldquo;hello&rdquo;];</p>
<p>var b = a[0], c = a[1];</p>
<p>console.log(b);</p>
<p>console.log(c);</p>
<p>Its output is as follows −</p>
<p>10</p>
<p>hello</p>
<h3 id="unions">Unions</h3>
<h3 id="84-typescript-unions">84) TypeScript Unions</h3>
<p>TypeScript 1.4 gives programs the ability to combine one or two types. Union types are a powerful way to express a value that can be one of the several types. Two or more data types are combined using the pipe symbol (|) to denote a Union Type. In other words, a union type is written as a sequence of types separated by vertical bars.</p>
<p>Syntax: Union literal</p>
<p>Type1|Type2|Type3</p>
<p>Example: Union Type Variable</p>
<p>var val:string|number</p>
<p>val = 12</p>
<p>console.log(&ldquo;numeric value of val &ldquo;+val)</p>
<p>val = &ldquo;This is a string&rdquo;</p>
<p>console.log(&ldquo;string value of val &ldquo;+val)</p>
<p>In the above example, the variable&rsquo;s type is union. It means that the variable can contain either a number or a string as its value.</p>
<p>On compiling, it will generate following JavaScript code.</p>
<p>//Generated by typescript 1.8.10</p>
<p>var val;</p>
<p>val = 12;</p>
<p>console.log(&ldquo;numeric value of val &quot; + val);</p>
<p>val = &ldquo;This is a string&rdquo;;</p>
<p>console.log(&ldquo;string value of val &quot; + val);</p>
<p>Its output is as follows −</p>
<p>numeric value of val 12</p>
<p>string value of val this is a string</p>
<h3 id="85union-type-and-arrays">85) Union Type and Arrays</h3>
<p>Union types can also be applied to arrays, properties and interfaces. The following illustrates the use of union type with an array.</p>
<p>Example: Union Type and Array</p>
<p>var arr:number[]|string[];</p>
<p>var i:number;</p>
<p>arr = [1,2,4]</p>
<p>console.log(&quot;**numeric array**&quot;)</p>
<p>for(i = 0;i&lt;arr.length;i++) {</p>
<p>console.log(arr[i])</p>
<p>}</p>
<p>arr = [&ldquo;Mumbai&rdquo;,&ldquo;Pune&rdquo;,&ldquo;Delhi&rdquo;]</p>
<p>console.log(&quot;**string array**&quot;)</p>
<p>for(i = 0;i&lt;arr.length;i++) {</p>
<p>console.log(arr[i])</p>
<p>}</p>
<p>The program declares an array. The array can represent either a numeric collection or a string collection.</p>
<p>On compiling, it will generate following JavaScript code.</p>
<p>//Generated by typescript 1.8.10</p>
<p>var arr;</p>
<p>var i;</p>
<p>arr = [1, 2, 4];</p>
<p>console.log(&quot;**numeric array**&quot;);</p>
<p>for (i = 0; i &lt; arr.length; i++) {</p>
<p>console.log(arr[i]);</p>
<p>}</p>
<p>arr = [&ldquo;Mumbai&rdquo;, &ldquo;Pune&rdquo;, &ldquo;Delhi&rdquo;];</p>
<p>console.log(&quot;**string array**&quot;);</p>
<p>for (i = 0; i &lt; arr.length; i++) {</p>
<p>console.log(arr[i]);</p>
<p>}</p>
<p>Its output is as follows −</p>
<p>**numeric array**</p>
<p>1</p>
<p>2</p>
<p>4</p>
<p>**string array**</p>
<p>Mumbai</p>
<p>Pune</p>
<p>Delhi</p>
<h2 id="typescript-namespaces">TypeScript Namespaces</h2>
<h3 id="86-typescript-namespaces">86) TypeScript Namespaces</h3>
<p>A namespace is a way to logically group related code. This is inbuilt into TypeScript unlike in JavaScript where variables declarations go into a global scope and if multiple JavaScript files are used within same project there will be possibility of overwriting or misconstruing the same variables, which will lead to the &ldquo;global namespace pollution problem&rdquo; in JavaScript.</p>
<p>Defining a Namespace</p>
<p>A namespace definition begins with the keyword namespace followed by the namespace name as follows −</p>
<p>namespace SomeNameSpaceName {</p>
<p>export interface ISomeInterfaceName { }</p>
<p>export class SomeClassName { }</p>
<p>}</p>
<p>The classes or interfaces which should be accessed outside the namespace should be marked with keyword export.</p>
<p>To access the class or interface in another namespace, the syntax will be namespaceName.className</p>
<p>SomeNameSpaceName.SomeClassName;</p>
<p>If the first namespace is in separate TypeScript file, then it should be referenced using triple slash reference syntax.</p>
<p>/// &lt;reference path = &ldquo;SomeFileName.ts&rdquo; /&gt;</p>
<h3 id="87nested-namespaces">87) Nested Namespaces</h3>
<p>You can define one namespace inside another namespace as follows −</p>
<p>namespace namespace_name1 {</p>
<p>export namespace namespace_name2 {</p>
<p>export class class_name { }</p>
<p>}</p>
<p>}</p>
<p>You can access members of nested namespace by using the dot (.) operator as follows −</p>
<p>FileName : Invoice.ts</p>
<p>namespace tutorialPoint {</p>
<p>export namespace invoiceApp {</p>
<p>export class Invoice {</p>
<p>public calculateDiscount(price: number) {</p>
<p>return price * .40;</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>FileName: InvoiceTest.ts</p>
<p>/// &lt;reference path = &ldquo;Invoice.ts&rdquo; /&gt;</p>
<p>var invoice = new tutorialPoint.invoiceApp.Invoice();</p>
<p>console.log(invoice.calculateDiscount(500));</p>
<p>The above code can be compiled and executed using the following command −</p>
<p>tsc &ndash;out app.js InvoiceTest.ts</p>
<p>node app.js</p>
<p>On compiling, it will generate following JavaScript code(app.js).</p>
<p>//Generated by typescript 1.8.10</p>
<p>var tutorialPoint;</p>
<p>(function (tutorialPoint) {</p>
<p>var invoiceApp;</p>
<p>(function (invoiceApp) {</p>
<p>var Invoice = (function () {</p>
<p>function Invoice() {</p>
<p>}</p>
<p>Invoice.prototype.calculateDiscount = function (price) {</p>
<p>return price * .40;</p>
<p>};</p>
<p>return Invoice;</p>
<p>}());</p>
<p>invoiceApp.Invoice = Invoice;</p>
<p>})(invoiceApp = tutorialPoint.invoiceApp || (tutorialPoint.invoiceApp = {}));</p>
<p>})(tutorialPoint || (tutorialPoint = {}));</p>
<p>/// &lt;reference path = &ldquo;Invoice.ts&rdquo; /&gt;</p>
<p>var invoice = new tutorialPoint.invoiceApp.Invoice();</p>
<p>console.log(invoice.calculateDiscount(500));</p>
<p>When the above code is compiled and executed, it produces the following result −</p>
<p>200</p>
<h2 id="modules">Modules</h2>
<h3 id="88-modules">88) Modules</h3>
<p>A module is designed with the idea to organize code written in TypeScript. Modules are broadly divided into −</p>
<ul>
<li>Internal Modules</li>
<li>External Modules</li>
</ul>
<h3 id="89internal-module">89) Internal Module</h3>
<p>Internal modules came in earlier version of Typescript. This was used to logically group classes, interfaces, functions into one unit and can be exported in another module. This logical grouping is named namespace in latest version of TypeScript. So internal modules are obsolete instead we can use namespace. Internal modules are still supported, but its recommended to use namespace over internal modules.</p>
<p>Internal Module Syntax (Old)</p>
<p>module TutorialPoint {</p>
<p>export function add(x, y) {</p>
<p>console.log(x+y);</p>
<p>}</p>
<p>}</p>
<p>Namespace Syntax (New)</p>
<p>namespace TutorialPoint {</p>
<p>export function add(x, y) { console.log(x + y);}</p>
<p>}</p>
<p>JavaScript generated in both cases are same</p>
<p>var TutorialPoint;</p>
<p>(function (TutorialPoint) {</p>
<p>function add(x, y) {</p>
<p>console.log(x + y);</p>
<p>}</p>
<p>TutorialPoint.add = add;</p>
<p>})(TutorialPoint || (TutorialPoint = {}));</p>
<h3 id="90external-module">90) External Module</h3>
<p>External modules in TypeScript exists to specify and load dependencies between multiple external js files. If there is only one js file used, then external modules are not relevant. Traditionally dependency management between JavaScript files was done using browser script tags (&lt;script&gt;&lt;/script&gt;). But that&rsquo;s not extendable, as its very linear while loading modules. That means instead of loading files one after other there is no asynchronous option to load modules. When you are programming js for the server for example NodeJs you don&rsquo;t even have script tags.</p>
<p>There are two scenarios for loading dependents js files from a single main JavaScript file.</p>
<p>Client Side - RequireJs</p>
<p>Server Side - NodeJs</p>
<p>Selecting a Module Loader</p>
<p>To support loading external JavaScript files, we need a module loader. This will be another js library. For browser the most common library used is RequieJS. This is an implementation of AMD (Asynchronous Module Definition) specification. Instead of loading files one after the other, AMD can load them all separately, even when they are dependent on each other.</p>
<p>Defining External Module :</p>
<p>When defining external module in TypeScript targeting CommonJS or AMD, each file is considered as a module. So it&rsquo;s optional to use internal module with in external module.</p>
<p>If you are migrating TypeScript from AMD to CommonJs module systems, then there is no additional work needed. The only thing you need to change is just the compiler flag Unlike in JavaScript there is an overhead in migrating from CommonJs to AMD or vice versa.</p>
<p>The syntax for declaring an external module is using keyword &lsquo;export&rsquo; and &lsquo;import&rsquo;.</p>
<p>Syntax</p>
<p>//FileName : SomeInterface.ts</p>
<p>export interface SomeInterface {</p>
<p>//code declarations</p>
<p>}</p>
<p>To use the declared module in another file, an import keyword is used as given below. The file name is only specified no extension used.</p>
<p>import someInterfaceRef = require(&quot;./SomeInterface&rdquo;);</p>
<p>Example :</p>
<p>Let&rsquo;s understand this using an example.</p>
<p>// IShape.ts</p>
<p>export interface IShape {</p>
<p>draw();</p>
<p>}</p>
<p>// Circle.ts</p>
<p>import shape = require(&quot;./IShape&rdquo;);</p>
<p>export class Circle implements shape.IShape {</p>
<p>public draw() {</p>
<p>console.log(&ldquo;Cirlce is drawn (external module)&quot;);</p>
<p>}</p>
<p>}</p>
<p>// Triangle.ts</p>
<p>import shape = require(&quot;./IShape&rdquo;);</p>
<p>export class Triangle implements shape.IShape {</p>
<p>public draw() {</p>
<p>console.log(&ldquo;Triangle is drawn (external module)&quot;);</p>
<p>}</p>
<p>}</p>
<p>// TestShape.ts</p>
<p>import shape = require(&quot;./IShape&rdquo;);</p>
<p>import circle = require(&quot;./Circle&rdquo;);</p>
<p>import triangle = require(&quot;./Triangle&rdquo;);</p>
<p>function drawAllShapes(shapeToDraw: shape.IShape) {</p>
<p>shapeToDraw.draw();</p>
<p>}</p>
<p>drawAllShapes(new circle.Circle());</p>
<p>drawAllShapes(new triangle.Triangle());</p>
<p>The command to compile the main TypeScript file for AMD systems is −</p>
<p>tsc &ndash;module amd TestShape.ts</p>
<h3 id="91-typescript-ambients">91) TypeScript Ambients</h3>
<p>Ambient declarations are a way of telling the TypeScript compiler that the actual source code exists elsewhere. When you are consuming a bunch of third party js libraries like jquery/angularjs/nodejs you can&rsquo;t rewrite it in TypeScript. Ensuring typesafety and intellisense while using these libraries will be challenging for a TypeScript programmer. Ambient declarations help to seamlessly integrate other js libraries into TypeScript.</p>
<p>Defining Ambients</p>
<p>Ambient declarations are by convention kept in a type declaration file with following extension (d.ts)</p>
<p>Sample.d.ts</p>
<p>The above file will not be transcompiled to JavaScript. It will be used for type safety and intellisense.</p>
<h3 id="92typescript-build-tools">92) TypeScript Build Tools</h3>
<p>Build tools are programming utilities which help to automate the transformation and bundling of our source code into a single file. A build tool utility is used to build a new version of a program. Building means compiling, linking, and packaging the code into the executable form.</p>
<p>The Build tools are usually run on the command line, either in IDE or completely separate from it.</p>
<p>Build tools or build automation is the act of scripting or automating a variety of tasks that developers do in their day-to-day activities. These are:</p>
<ul>
<li>Downloading dependencies.</li>
<li>Compiling source code into binary code.</li>
<li>Packaging that binary code.</li>
<li>Running tests.</li>
<li>Deployment to production systems.</li>
</ul>
<p>Use of build tools :</p>
<p>In small projects, the software developers manually invoke the build process, which is not a good practice for larger projects. It is because, in larger projects, it is very hard to keep track of what needs to be built, in what sequence and what should be the dependencies in the building process. So we use an automation tool which allows the build process to be more consistent.</p>
<h2 id="libraries-identification">Libraries Identification</h2>
<h3 id="93-libraries-in-typescript">93) Libraries in TypeScript</h3>
<p>Broadly speaking, the way you structure your declaration file depends on how the library is consumed. There are many ways of offering a library for consumption in JavaScript, and you’ll need to write your declaration file to match it.Identifying the structure of a library is the first step in writing its declaration file.</p>
<h3 id="94modular-libraries">94) Modular Libraries</h3>
<p>Almost every modern Node.js library falls into the module family. These type of libraries only work in a JS environment with a module loader. For example, express only works in Node.js and must be loaded using the CommonJS require function.</p>
<p>ECMAScript 2015 (also known as ES2015, ECMAScript 6, and ES6), CommonJS, and RequireJS have similar notions of importing a module. In JavaScript CommonJS (Node.js), for example, you would write</p>
<p>var fs = require(&ldquo;fs&rdquo;);</p>
<p>In TypeScript or ES6, the import keyword serves the same purpose:</p>
<p>import * as fs from &ldquo;fs&rdquo;;</p>
<p>You&rsquo;ll typically see modular libraries include one of these lines in their documentation:</p>
<p>var someLib = require(&ldquo;someLib&rdquo;);</p>
<p>or</p>
<p>define(&hellip;, [&lsquo;someLib&rsquo;], function(someLib) {</p>
<p>});</p>
<h3 id="95identifying-a-module-library-from-code">95) Identifying a Module Library from Code</h3>
<p>Modular libraries will typically have at least some of the following:</p>
<ul>
<li>Unconditional calls to require or define</li>
<li>Declarations like import * as a from &lsquo;b&rsquo;; or export c;</li>
<li>Assignments to exports or module.exports</li>
</ul>
<p>They will rarely have:</p>
<ul>
<li>Assignments to properties of window or global</li>
</ul>
<h3 id="96-templates-for-modules">96) Templates for Modules</h3>
<p>1&raquo; Then use the template module-function.d.ts if your module can be called like a function:</p>
<p>const x = require(&ldquo;foo&rdquo;);</p>
<p>// Note: calling &lsquo;x&rsquo; as a function</p>
<p>const y = x(42);</p>
<p>2&raquo; Use the template module-class.d.ts if your module can be constructed using new:</p>
<p>const x = require(&ldquo;bar&rdquo;);</p>
<p>// Note: using &lsquo;new&rsquo; operator on the imported variable</p>
<p>const y = new x(&ldquo;hello&rdquo;);</p>
<p>3&raquo; If you have a module which when imported, makes changes to other modules use template module-plugin.d.ts:</p>
<p>const jest = require(&ldquo;jest&rdquo;);</p>
<p>require(&ldquo;jest-matchers-files&rdquo;);</p>
<h3 id="97global-libraries">97) Global Libraries</h3>
<p>A global library is one that can be accessed from the global scope (i.e. without using any form of import). Many libraries simply expose one or more global variables for use. For example, if you were using jQuery, the $ variable can be used by simply referring to it:</p>
<p>$(() =&gt; {</p>
<p>console.log(&ldquo;hello!&quot;);</p>
<p>});</p>
<p>You&rsquo;ll usually see guidance in the documentation of a global library of how to use the library in an HTML script tag:</p>
<p>&lt;script src=&quot;http://a.great.cdn.for/someLib.js&rdquo;&gt;&lt;/script&gt;</p>
<p>Today, most popular globally-accessible libraries are actually written as UMD libraries (see below). UMD library documentation is hard to distinguish from global library documentation. Before writing a global declaration file, make sure the library isn’t actually UMD.</p>
<h3 id="98identifying-a-global-library-from-code">98) Identifying a Global Library from Code</h3>
<p>Global library code is usually extremely simple. A global &ldquo;Hello, world&rdquo; library might look like this:</p>
<p>function createGreeting(s) {</p>
<p>return &ldquo;Hello, &quot; + s;</p>
<p>}</p>
<p>or like this:</p>
<p>// Web</p>
<p>window.createGreeting = function (s) {</p>
<p>return &ldquo;Hello, &quot; + s;</p>
<p>};</p>
<p>// Node</p>
<p>global.createGreeting = function (s) {</p>
<p>return &ldquo;Hello, &quot; + s;</p>
<p>};</p>
<p>// Potentially any runtime</p>
<p>globalThis.createGreeting = function (s) {</p>
<p>return &ldquo;Hello, &quot; + s;</p>
<p>};</p>
<p>When looking at the code of a global library, you&rsquo;ll usually see:</p>
<ul>
<li>Top-level var statements or function declarations</li>
<li>One or more assignments to window.someName</li>
<li>Assumptions that DOM primitives like document or window exist</li>
</ul>
<p>Examples of Global Libraries :</p>
<p>Because it&rsquo;s usually easy to turn a global library into a UMD library, very few popular libraries are still written in the global style. However, libraries that are small and require the DOM (or have no dependencies) may still be global.</p>
<p>Global Library Template :</p>
<p>The template file global.d.ts defines an example library myLib.</p>
<h3 id="99-umd">99) UMD</h3>
<p>A UMD module is one that can either be used as module (through an import), or as a global (when run in an environment without a module loader). Many popular libraries, such as Moment.js, are written this way. For example, in Node.js or using RequireJS, you would write:</p>
<p>import moment = require(&ldquo;moment&rdquo;);</p>
<p>console.log(moment.format());</p>
<p>whereas in a vanilla browser environment you would write:</p>
<p>console.log(moment.format());</p>
<p>Identifying a UMD library :</p>
<p>UMD modules check for the existence of a module loader environment. This is an easy-to-spot pattern that looks something like this:</p>
<p>(function (root, factory) {</p>
<p>if (typeof define === &ldquo;function&rdquo; &amp;&amp; define.amd) {</p>
<p>define([&ldquo;libName&rdquo;], factory);</p>
<p>} else if (typeof module === &ldquo;object&rdquo; &amp;&amp; module.exports) {</p>
<p>module.exports = factory(require(&ldquo;libName&rdquo;));</p>
<p>} else {</p>
<p>root.returnExports = factory(root.libName);</p>
<p>}</p>
<p>}(this, function (b) {</p>
<p>If you see tests for typeof define, typeof window, or typeof module in the code of a library, especially at the top of the file, it&rsquo;s almost always a UMD library.</p>
<p>Documentation for UMD libraries will also often demonstrate a &ldquo;Using in Node.js&rdquo; example showing require, and a &ldquo;Using in the browser&rdquo; example showing using a &lt;script&gt; tag to load the script.</p>
<p>Examples of UMD libraries :</p>
<p>Most popular libraries are now available as UMD packages. Examples include jQuery, Moment.js, lodash, and many more.</p>
<p>Template:</p>
<p>Use the module-plugin.d.ts template.</p>
<h3 id="100-dependencies">100) Dependencies</h3>
<p>Consuming Dependencies - There are several kinds of dependencies your library might have. This section shows how to import them into the declaration file.</p>
<p>Dependencies on Global Libraries</p>
<p>If your library depends on a global library, use a /// &lt;reference types=&rdquo;&hellip;&rdquo; /&gt; directive:</p>
<p>/// &lt;reference types=&quot;someLib&rdquo; /&gt;</p>
<p>function getThing(): someLib.thing;</p>
<p>Dependencies on Modules :</p>
<p>If your library depends on a module, use an import statement:</p>
<p>import * as moment from &ldquo;moment&rdquo;;</p>
<p>function getThing(): moment;</p>
<p>Dependencies on UMD libraries</p>
<p>From a Global Library :</p>
<p>If your global library depends on a UMD module, use a /// &lt;reference types directive:</p>
<p>/// &lt;reference types=&quot;moment&rdquo; /&gt;</p>
<p>function getThing(): moment;</p>
<p>From a Module or UMD Library :</p>
<p>If your module or UMD library depends on a UMD library, use an import statement:</p>
<p>import * as someLib from &ldquo;someLib&rdquo;;</p>
<p>Do not use a /// &lt;reference directive to declare a dependency to a UMD library!</p>



                    </div>
                </div>
            </div>
        </div>
    </div>

    <section id="comments">
    <div class="py-3 content">
        <div class="container">
            <div class="row justify-content-center">
                <div class="col-sm-12 col-lg-8">
                    <div class="comments">
                        <script src="https://utteranc.es/client.js" repo=""
                            issue-term="pathname" label="comment" theme="github-light" crossorigin="anonymous" async>
                            </script>
                    </div>
                </div>
            </div>
        </div>
    </div>
</section>
    


    

    
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.0/highlight.min.js" integrity="sha512-TDKKr+IvoqZnPzc3l35hdjpHD0m+b2EC2SrLEgKDRWpxf2rFCxemkgvJ5kfU48ip+Y+m2XVKyOCD85ybtlZDmw==" crossorigin="anonymous"></script>
        
            <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.0/languages/r.min.js" defer></script>
        
            <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.0/languages/python.min.js" defer></script>
        
            <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.0/languages/stan.min.js" defer></script>
        
        <script>
            window.addEventListener('load', function() {
                hljs.initHighlighting();
            }, true);
        </script>
    

    

    
    
        
<script src="https://example.com/js/math-code.js"></script>
<script async src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"></script>


    
</body>

</html>
